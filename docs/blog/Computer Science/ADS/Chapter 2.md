---
hide:
  #- navigation # 显示右
  #- toc #显示左
  - footer
  - feedback
# comments: true
--- 

# Chapter 02 : Red-Black Trees and B+ Trees

## Red-Black Trees

### Why?

> 跟 AVL 树和 Splay 树一样，红黑树被发明出来也是希望能维护一个相对平衡的二叉搜索树

***
### Definition

!!! Definition "Red-Black Tree"

	红黑树是满足如下性质的一种二叉搜索树：
	
	- 每个节点不是红色就是黑色
	- 根节点为黑色
	- NIL 节点（空叶子节点）为黑色
	- 如果一个节点是红色，那么它的两个子节点都是黑色
	- 从根节点到 NIL 节点的每条路径上的黑色节点数量相同
	
	下图为一合法的红黑树：
	
	![](../../../assets/Pasted image 20240921110036.png)

!!! Definition "Black-Height"

	对于任何一个节点 $x$，它的黑高（Black-Height），记作 $\text{bh}(x)$，等于该节点到 NIL 结点的简单路径中（不包括自身）黑色节点的数量。$\text{bh}(Tree)=\text{bh}(root)$

!!! Lemma

	=== "Lemma"
	
		一个有 $N$ 个内部节点（不包括 NIL 结点）的红黑树，其高度最大为 $2log⁡_2(N+1)$。
	
	=== "Proof"
	
		我们首先证明 $\text{bh}(Tree)\leq log_2(N+1)$，即对于任意节点 $x$，$\text{sizeof}(x)(以 x 为根节点的子树的内部节点个数)\geq 2^{\text{bh}(x)}-1$，用数学归纳法来证明：
		
		如果 $h(x)=0$，$x$ 为 NULL $\Rightarrow\text{sizeof}(x)=2^0-1=0$，成立。
		
		假设如果对于每一个满足 $h(x)\leq k$ 的 $x$ 结论都成立：
		
		对于 $h(x)=k+1$ 的节点 $x$，$\text{bh}(\text{child})=\text{bh}(x)$ 或 $\text{bh}(x)-1$
		
		很容易可以得到 $h(\text{child})\leq k$，而根据数学归纳法的假设，此时 $\text{sizeof}(\text{child})\geq 2^{\text{bh}(\text{child})}-1\geq 2^{\text{bh}(x)-1}-1$
		
		这样我们就有 $\text{sizeof}(x)=1+2\text{sizeof}(\text{child})\geq 2^{\text{bh}(x)}-1$，证毕。
		
		***
		
		再接着我们来证明 $\text{bh}(\text{Tree})\geq\frac{h(\text{Tree})}{2}$
		
		对于每一个红节点，由红黑树性质其两个孩子节点一定都是黑节点，因此每一条从根节点到 NIL 的简单路径中，至少有一半的节点（不包含根节点）是黑色的，那么就能证明这个命题。
		
		***
		
		综合以上两个命题的证明，我们有 $h(\text{Tree})\leq 2\text{bh}(\text{Tree})\leq 2log_2(N+1)$，证毕。

!!! Example "Example 01"

	=== "Question"
	
		下图的红黑树是否合法？
		
		![](../../../assets/Pasted image 20240921111709.png)
	
	=== "Answer"
	
		不合法。
		
		16 号节点的右儿子是一个黑 NIL 节点，而这个 NIL 节点到根的路径上只有 3 个黑节点，而其他 NIL 节点到根都有 4 个黑节点。
		
		所以我们需要**警惕只有一个非 NIL 节点儿子的红色节点**。

根据 Example 01，我们得到这样一个结论：<font color="red">合法红黑树不存在只有一个非 NIL 节点儿子的红色节点！</font>换句话说，<font color="red">合法红黑树的红色节点的两个子节点一定都是 NIL 节点或都不是 NIL 节点！</font>

!!! Example "Example 02"

	=== "Question"
	
		下图的红黑树是否合法？
		
		![](../../../assets/Pasted image 20240921112334.png)
	
	=== "Answer"
	
		合法。

***
### Operations

#### Insertion

我们知道，对**黑高**有贡献的只有黑色节点，因此 NIL 节点被一个**红色**节点置换并不会改变一颗红黑树的黑高，因为红色节点还会有一层 NIL 子节点；然而对于红色节点，却有着红色结点互不相邻的限制。

因此，“插入”操作的主要思路就是，先将整个红黑树当作一个普通的二叉搜索树，将目标数据插入到树的末端（也就是置换一个 NIL 节点），并将它染为红色，再调整使之在保证**黑高不变**的情况下，满足**红色节点不能相邻**的要求。

现在，我们记这个被插入的节点为 $x$，任意一个节点 $node$ 的家长节点为 $node.p$，则：

1. 如果 $x.p$ 是黑色的，那么我们不需要做任何调整；
2. 如果 $x.p$ 是红色的，那么我们需要进行调整；
    - 此时因为原来的树符合红黑性质，$x.p.p$ 必定存在（红 $x.p$ 不能是根）且必定是黑色的；

在插入节点后，有可能会破坏红黑树的红黑性质（即上面第二条的情况），我们需要进行调整，并且在调整过程中，有一部分需要进行递归转移，也有可能再次出现类似的情况，我们将所有可能出现的情况归纳成下图 3 种情况（这张图中的叶子节点指 NIL 节点，“被插入的红色节点”也可能是在调整过程中**红黑性质被破坏的红根子树**）：

![](../../../assets/Pasted%20image%2020240921121440.png)

接下来我们来看该如何处理这三种情况（由于 case 之间可能出现互相转化，下面采取 case 3$\rightarrow$case 1 的顺序进行介绍，这样更为合理）：

!!! Operation

	=== "Case 3"
	
		对于 Case 3，我们只需要进行重新染色，并且进行一次旋转即可。
		
		![](../../../assets/Pasted image 20240921122125.png)
	
	=== "Case 2"
	
		对于 Case 2，我们直接进行一次 Rotation 操作即可将其变为 Case 3。
		
		事实上，整个 Case 2 到最后调整完成的过程其实就是一个 LR Rotation。
		
		![](../../../assets/Pasted image 20240921122319.png)
	
	=== "Case 1"
	
		对于 Case 1，图中两种情况是等价的。
		
		我们只需要将图中的根节点**染红**，将根的两个子节点**染黑**，类似于将黑节点“下放”。
		
		通过第一步操作，我们可以保证这整个子树必定**平衡**、**不影响家长节点的黑高**（除了家长是根的情况）且**红点不邻**的。
		
		然而我们并不知道这个根的家长节点是否是红色节点，因此要作如下图的分类讨论。倘若其根的家长节点是红色节点，那么我们还需要向上递归，继续调整，根据实际情况转化为其他 case；若这子树的根没有家长节点，则直接染黑红根即可；而倘若子树根节点的家长节点是黑节点，那么我们就调整完毕了。
		
		![](../../../assets/Pasted image 20240921144446.png)
		

总结起来，我们可以用一个状态机来概括：

![](../../../assets/Pasted%20image%2020240921144801.png)

其中 $C$ 表示染色操作，$R$ 表示旋转操作；状态机中的**粗线**表示转换过程中，我们关注的“子树”向上攀升了一级；而**细线**表示我们关注的子树仍然是这一层的那一棵。

其中，任何一个情况都可以作为一个初始情况。所以可以数出，到达 finish 的路径中，最多出现 2 次 Rotation（case 2 $\rightarrow$ case 3 $\rightarrow$ finish）。
***
#### Deletion

> <font color="red">这里的删除方法与那沟槽的 PPT 有不同！补药看那沟槽 PPT 看</font> [OI Wiki](https://oi-wiki.org/ds/rbtree/#%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C) <font color="red">这个方法！</font>（Midterm 因为这个爆亏 6 分 www）【这便是 Bruce 反感课内课程的开始】

对于删除操作，我们先不管红黑性质，按照常规二叉搜索树的删除操作将其删除：

- 首先通过二分找到我们要删除的元素，这里需要 $O(\log N)$ 的时间复杂度
- 对这个节点进行分类讨论：

1. 如果该节点为树中唯一节点的话，直接删除即可
2. 如果该节点既有左子节点又有右子节点，则用它的前驱或后继节点进行替换（仅替换数据，不改变节点颜色和内部引用关系），值得注意也可以证明（或者感性感受一下）的是，它的前驱或后继节点保证不会是一个既有非 NIL 左子节点又有非 NIL 右子节点的节点，所以可以跳转到第 3 或第 4 条递归删除前驱/后继节点（现在应该是当前节点的值了）
3. 如果该节点为叶子节点，若该节点为红色，直接删除即可；如果为黑色，则平衡树性质被打破，需要重新维护
4. 如果该节点有且仅有一个非 NIL 子节点，则子节点 S 一定为红色（这个上面的 Example 01 也已经说明了），那么待删除节点 N 为黑色，所以直接使用子节点 S 替代 N 并将其染黑后即可

可以看到上面只有情况 3 需要重新维护，其他情况都可以一下解决。对此我们还是将情况分为 4 种（同样的，这里的叶子节点指 NIL 节点；“需要被删除的目标点”由于递归转移，也可能是**由于删除了某个结点，黑高 -1 的子树**【请记住这个点，Bruce 因为这个没明白倒腾了一下午也没搞清楚删除操作的 qwq】）：

![](../../../assets/Pasted%20image%2020240921151415.png)

??? Question "x 到底何时删去？"

	如上面所说的，在一开始我们就可以找到 x 并根据不同情况将其删去，但是后续的操作我们仍旧保留了这个“需要被删除的目标点” 概念，是为了更便于理解，更直观地能看出操作的进程（可以把这个点当作一个虚空的点，或者就是 NIL 节点）
	其实我们可以统一这个定义为“由于删除了某个结点，黑高 -1 的子树”（因为删除了这个黑目标点就等价于以这个节点为根节点的子树黑高 -1 了，在第一轮调整时就需要以这个节点为 x 进行调整）

类似于我们在「Insertion / Case 1」里提到的“下放”黑节点，删除操作的思路基本上是“上放”黑节点，或者说“吸纳”黑节点。这个“吸纳”的行为，指的是一个黑点，原来只为右子树中的所有路径提供了黑高，现在由于它的 sibling 子树中少了一个黑色节点，我们将这个黑色节点转移到它们的家长节点，于是这个节点同时为左右子树的所有路径都贡献了黑高，保证为左子树再提供一个黑高的同时右子树黑高不变。

接下来我们逐个分析这四种情况（<font color="red">请记住，在每一轮调整结束之后我们要寻找那个黑高 -1 的子树【值得注意的是，我们只需要在删掉的点到根路径上面的这一些树根寻找，因为在前面的交换操作中没有改变树的形态，只有在最后删除这里减少了一个黑点。所以后续的平衡维护的过程中其实都是在调整这一条链上的树】，将它作为 x 再来看这四种情况该用哪一种【这是删除的关键！】</font>）：

!!! Operation

	=== "Case 1"
	
		Case 1 根据 $a$ 的红黑还可以继续分为两种情况：
		
		![](../../../assets/Pasted image 20240921193629.png)
		
		=== "Case 1.1"
		
			当 a 为红根时，由于 x 贡献了（相对于原红黑树）-1 的黑高，为了保证整个子树贡献的黑高不变，我们考虑把 w 的黑高“上放”到 a 上，也就是从下面“吸纳”上来。
			
			![](../../../assets/Pasted image 20240921193919.png)
		
		=== "Case 1.2"
		
			当 a 为黑根时，我们没有空余的位置来“吸纳” w 的黑高，但是左子树和右子树的不平衡是必须解决的，而我们绝不能寄希望于“在不知道有没有红色节点的 b 和 c 的子树中去寻找红色节点”这个想法。
			
			所以我们可以将整个树标记为灰色（即将 a 作为 x），然后进一步根据其家长节点的情况递归到其他 case。其中，当我们递归到 a 是整个树的根时可以退出，因为这相当于整个树的黑高 -1，不影响红黑性质。
			
			![](../../../assets/Pasted image 20240921195638.png)
	
	=== "Case 2"
	
		Case 2 操作如下：
		
		1. 将 w 染为 a 的颜色，再将 a 和 c 染成黑色；
		2. 将 a 左旋，使 w 成为这个子树新的根，a 成为 w 的左儿子，b 成为 a 的右儿子；
		3. 调整结束；
	
		![](../../../assets/Pasted image 20240921201124.png)
	
	=== "Case 3"
	
		Case 3 操作如下：
		
		1. 交换 b 和 w 的颜色；
		2. 将 w 右旋，使 b 成为 a 的右儿子，w 成为 b 的右儿子，b 的右儿子成为 w 的左儿子；
		3. 此时情况转化为 case 2；
	
		![](../../../assets/Pasted image 20240921201830.png)
	
	=== "Case 4"
	
		Case 4 操作如下：
		
		1. 交换 a 和 w 的颜色；
		2. 将 a 左旋，使 w 成为这个子树新的根，a 成为 w 的左儿子，b 成为 a 的右儿子；
		3. 此时根据子树 a 的情况，转化为 case 1.1 / case 2 / case 3；
	
		![](../../../assets/Pasted image 20240921202958.png)

我们同样可以用状态机来概括这个过程：

![](../../../assets/Pasted%20image%2020240921203718.png)

其中 $C$ 表示染色操作，$R$ 表示旋转操作；状态机中的**粗线**表示转换过程中，我们关注的“子树”向上或向下转移了一级（由 case 4 出发时下降，由 case 1.2 出发时上升）；而**细线**表示我们关注的子树仍然是这一层的那一棵。

其中，任何一个情况都可以作为一个初始情况。所以可以数出，到达 finish 的路径中，最多出现 3 次 Rotation（case 4 $\rightarrow$ case 3 $\rightarrow$ case 2 $\rightarrow$ finish）。

***

根据前面状态机的相关内容，我们不难得到这张表格，它统计的是 Rotation 在不同数据结构、不同操作中出现的数量：

| **Option** | **AVL Tree** | **RB Tree** |
| ---------- | ------------ | ----------- |
| Insertion  | $\leq 2$     | $\leq 2$    |
| Deletion   | $O(\log N)$  | $\leq 3$    |

***
## B+ Tree

### Why?

B+ 树是一种用树状形式维护有序数列比较信息的数据结构，其增改操作拥相对于二叉树结构更加稳定的对数时间复杂度，通常用于数据库和操作系统的文件系统中。
***
### Definition

!!! Definition "B+ Tree"

	一个 $M$ 阶（一般 $M$ 取 $3$ 或 $4$）$B+$ 树是满足如下结构性质的树：
	
	- 根节点要么是叶子节点，要么有 $2～M$ 个孩子
	- 所有非叶子节点（除了根节点）有 $\lceil \frac{M}{2} \rceil$～$M$ 个孩子
	- 所有叶子节点都在同一层
	
	> 假设每一个非根的叶子节点也都有 $\lceil \frac{M}{2} \rceil$～$M$ 个孩子
	
	如下图就是一个 $M=4$ 的 $B+$ 树（也可称为 $2-3-4$ 树）：
	
	![](../../../assets/Pasted image 20240921210830.png)
	
	所有真实的数据都被存储在叶子结点中，形成一个有序的数列。而非叶子结点中第 $i$ 个键值等于其第 $i+1$ 棵子树的最小值（在上图中表现为颜色相同的一对上下结点），因此非叶结点最多存 $M−1$ 个值。

!!! Properties

	- 对于 $B+$ 树，将它的叶子结点拼接起来，实际上就是一个有序数列
	- 在存储数值不重复的情况下，非叶结点存储的键值都不相同
	
	!!! Proof
	
		对于任意一个非叶子结点，它存储的值必定不会被它的子节点存储（如果它的子节点不是叶子），因为它存的是它的子节点的第一个子树的最小值，而它的子节点存的是第二个子树开始的最小值。

抽象地来说就是，我们把一个数列相对均匀的分为 $m$ 块，然后把分界的数拿出来。当我们去查找或插入时，只需要和这些边界数进行比较，就知道它应该放在哪一块里。再不断细化粒度，用类似于“$m$ 分”的思想来找到目标位置。

!!! note "Depth of B+ Tree"

	由于它在空间最浪费的情况下是一棵 $\lceil \frac{M}{2} \rceil$ 叉树，所以 $B+$ 树的深度为 $O(\log_{\lceil \frac{M}{2} \rceil} N)$

### Operations

#### Query

$B+$ 树的查找和二叉树的查找十分相似

!!! Example "Find(43)"

	=== "Step 1"
	
		![](../../../assets/Pasted image 20240922082208.png)
		
		我们发现有 $21\leq 43<48$，所以顺着标识的橙色指针向下。
	
	=== "Step 2"
	
		![](../../../assets/Pasted image 20240922082255.png)
		
		我们发现有 $41\leq 43$，所以顺着标识的橙色指针向下。
	
	=== "Step 3"
	
		![](../../../assets/Pasted image 20240922082338.png)
		
		已经走到叶子结点，最后发现我们要找的 43。

***
#### Insertion

插入的方法也相对朴素简单，就是找到该插入的地方以后插入即可。

只不过需要注意一件事，当这个插入，导致了 $B+$ 树的性质不再成立时，即导致其家长节点的子节点数量为 $M+1$ 时，我们需要将这个结点平均分裂成两个，此时显然有两个子树的节点数量都不小于 $\lceil M+1\rceil$。但这还不够，分裂导致家长节点的家长节点的子节点变多，所以我们还得向上递归。

!!! Example "Insert(46)"

	=== "Step 1"
	
		![](../../../assets/Pasted image 20240922082653.png)
		
		同查找，略。
	
	=== "Step 2"
	
		![](../../../assets/Pasted image 20240922082741.png)
		
		同查找，略。
	
	=== "Step 3"
	
		![](../../../assets/Pasted image 20240922082823.png)
		
		找到要塞的位置了，发现要塞的地方是 45 的后面，插入以后发现一共 4 个数，而 $M=4$，不需要分裂。

!!! Example "Insert(44)"

	=== "Step 1"
	
		![](../../../assets/Pasted image 20240922082921.png)
		
		同查找，略。
	
	=== "Step 2"
	
		![](../../../assets/Pasted image 20240922082955.png)
		
		同查找，略。
	
	=== "Step 3"
	
		![](../../../assets/Pasted image 20240922083032.png)
		
		找到要塞的位置了，发现要塞的地方是 45 的前面，插入以后发现一共 5 个数，而 $M=4$，需要分裂！
	
	=== "Step 4"
	
		![](../../../assets/Pasted image 20240922083115.png)
		
		向上递归，我们发现，这个节点在分裂后有了 5 个子节点，不得不再次分裂。
	
	=== "Step 5"
	
		![](../../../assets/Pasted image 20240922083200.png)
		
		向上递归，我们发现根部出现问题，这下我们要分裂根部了！
	
	=== "Step 6"
	
		![](../../../assets/Pasted image 20240922083247.png)
		
		由于根部被裂开了，所以我们需要添加一个新的根，这也意味着树的层数增高了。
		
		现在，我们终于完成了插入。
***
## Homework

!!! question "Question 01-Midterm"

	Is it true that a red-black tree Deletion operation requires O(1) nodes recoloring in the worst case?
	
	??? note "Answer"
	
		False. 我们根据上面画的状态机可以发现，Recolor 操作是每个 Case 都需要发生的，但是 Rotation 操作并不是，所以期中的时候对应的第二套题目考的就是 Rotation 是不是 $O(1)$，第二套应该是对的，在这里则不是，为 $O(\log N)$（期中的时候误认为 Recolor 只伴随 Rotation 一起发生了实际上是可以只 Recolor 不 Rotation 的 www）

!!! question "Question 02-Midterm"

	After deleting 10 from the red-black tree given in the figure, which one of the following statements must be FALSE?
	
	![](../../../assets/Pasted%20image%2020241223220729.png)
	
	- A. 8 is the parent of 15, and there are 2 red nodes in the tree
	- B. 11 is the parent of 6, and 14 is red
	- C. 8 is the parent of 15, and 7 is black
	- D. 11 is the parent of 15, and there are 2 red nodes in the tree
	
	??? note "Answer"
	
		A. 8 is the parent of 15, and there are 2 red nodes in the tree
		
		根据上面描述的删除做法，可以得到两种情况：（分别是用前驱节点 8 和后继节点 11 替换的情况，其中画圈表示为红色）
		
		![](../../../assets/Pasted%20image%2020241223221017.png)
		
		其中如果按照 PPT 的做法用 8 替换不会长这样（因为它不考虑我们所讲的情况 4 直接一股脑直接用四个 Case 干，这样固然能得到一个正确的删法但是就会造成两个答案（沟槽 ADS 出个题还不跟自己远古 PPT 对应的什么破课导致我爆亏 6 分）
		
		??? warning "大骂 ADS 破防时刻"
		
			![](../../../assets/Pasted%20image%2020241223223905.png)
