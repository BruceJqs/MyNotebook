---
hide:
  #- navigation # 显示右
  #- toc #显示左
  - footer
  - feedback
comments: true
--- 

# Chapter 02 : Red-Black Trees and B+ Trees

## Red-Black Trees

### Why?

> 跟 AVL 树和 Splay 树一样，红黑树被发明出来也是希望能维护一个相对平衡的二叉搜索树

***
### Definition

!!! Definition "Red-Black Tree"

	红黑树是满足如下性质的一种二叉搜索树：
	
	- 每个节点不是红色就是黑色
	- 根节点为黑色
	- NIL 节点（空叶子节点）为黑色
	- 如果一个节点是红色，那么它的两个子节点都是黑色
	- 从根节点到 NIL 节点的每条路径上的黑色节点数量相同
	
	下图为一合法的红黑树：
	
	![](../../../assets/Pasted image 20240921110036.png)

!!! Definition "Black-Height"

	对于任何一个节点 $x$，它的黑高（Black-Height），记作 $bh(x)$，等于该节点到 NIL 结点的简单路径中（不包括自身）黑色节点的数量。$bh(Tree)=bh(root)$

!!! Lemma

	=== "Lemma"
	
		一个有 $N$ 个内部节点（不包括 NIL 结点）的红黑树，其高度最大为 $2log⁡_2(N+1)$。
	
	=== "Proof"
	
		我们首先证明 $bh(Tree)\leq log_2(N+1)$，即对于任意节点 $x$，$sizeof(x)(以 x 为根节点的子树的内部节点个数)\geq 2^{bh(x)}-1$，用数学归纳法来证明：
		
		如果 $h(x)=0$，$x$ 为 NULL $\Rightarrow sizeof(x)=2^0-1=0$，成立。
		
		假设如果对于每一个满足 $h(x)\leq k$ 的 $x$ 结论都成立：
		
		对于 $h(x)=k+1$ 的节点 $x$，$bh(child)=bh(x)或bh(x)-1$
		
		很容易可以得到 $h(child)\leq k$，而根据数学归纳法的假设，此时 $sizeof(child)\geq 2^{bh(child)}-1\geq 2^{bh(x)-1}-1$
		
		这样我们就有 $sizeof(x)=1+2sizeof(child)\geq 2^{bh(x)}-1$，证毕。
		
		***
		
		再接着我们来证明 $bh(Tree)\geq\frac{h(Tree)}{2}$
		
		对于每一个红节点，由红黑树性质其两个孩子节点一定都是黑节点，因此每一条从根节点到 NIL 的简单路径中，至少有一半的节点（不包含根节点）是黑色的，那么就能证明这个命题。
		
		***
		
		综合以上两个命题的证明，我们有 $h(Tree)\leq 2bh(Tree)\leq 2log_2(N+1)$，证毕。

!!! Example "Example 01"

	=== "Question"
	
		下图的红黑树是否合法？
		
		![](../../../assets/Pasted image 20240921111709.png)
	
	=== "Answer"
	
		不合法。
		
		16 号节点的右儿子是一个黑 NIL 节点，而这个 NIL 节点到根的路径上只有 3 个黑节点，而其他 NIL 节点到根都有 4 个黑节点。
		
		所以我们需要**警惕只有一个非 NIL 节点儿子的红色节点**。

根据 Example 01，我们得到这样一个结论：<font color="red">合法红黑树不存在只有一个非 NIL 节点儿子的红色节点！</font>换句话说，<font color="red">合法红黑树的红色节点的两个子节点一定都是 NIL 节点或都不是 NIL 节点！</font>

!!! Example "Example 02"

	=== "Question"
	
		下图的红黑树是否合法？
		
		![](../../../assets/Pasted image 20240921112334.png)
	
	=== "Answer"
	
		合法。

***
### Operations

#### Insertion

我们知道，对**黑高**有贡献的只有黑色节点，因此 NIL 节点被一个**红色**节点置换并不会改变一颗红黑树的黑高，因为红色节点还会有一层 NIL 子节点；然而对于红色节点，却有着红色结点互不相邻的限制。

因此，“插入”操作的主要思路就是，先将整个红黑树当作一个普通的二叉搜索树，将目标数据插入到树的末端（也就是置换一个 NIL 节点），并将它染为红色，再调整使之在保证**黑高不变**的情况下，满足**红色节点不能相邻**的要求。

现在，我们记这个被插入的节点为 $x$，任意一个节点 $node$ 的家长节点为 $node.p$，则：

1. 如果 $x.p$ 是黑色的，那么我们不需要做任何调整；
2. 如果 $x.p$ 是红色的，那么我们需要进行调整；
    - 此时因为原来的树符合红黑性质，$x.p.p$ 必定存在（红 $x.p$ 不能是根）且必定是黑色的；

在插入节点后，有可能会破坏红黑树的红黑性质（即上面第二条的情况），我们需要进行调整，并且在调整过程中，有一部分需要进行递归转移，也有可能再次出现类似的情况，我们将所有可能出现的情况归纳成下图 3 种情况（这张图中的叶子节点指 NIL 节点，被插入的红色节点也可能是在调整过程中**红黑性质被破坏的红根子树**）：

![](../../../assets/Pasted%20image%2020240921121440.png)

接下来我们来看该如何处理这三种情况（由于 case 之间可能出现互相转化，下面采取 case 3$\rightarrow$case 1 的顺序进行介绍，这样更为合理）：

!!! Operation

	=== "Case 3"
	
		对于 Case 3，我们只需要进行重新染色，并且进行一次旋转即可。
		
		![](../../../assets/Pasted image 20240921122125.png)
	
	=== "Case 2"
	
		对于 Case 2，我们直接进行一次 Rotation 操作即可将其变为 Case 3。
		
		事实上，整个 Case 2 到最后调整完成的过程其实就是一个 LR Rotation。
		
		![](../../../assets/Pasted image 20240921122319.png)
	
	=== "Case 1"
	
		对于 Case 1，图中两种情况是等价的。
		
		我们只需要将图中的根节点**染红**，将根的两个子节点**染黑**，类似于将黑节点“下放”。
		
		通过第一步操作，我们可以保证这整个子树必定**平衡**、**不影响家长节点的黑高**（除了家长是根的情况）且**红点不邻**的。
		
		然而我们并不知道这个根的家长节点是否是红色节点，因此要作如下图的分类讨论。倘若其根的家长节点是红色节点，那么我们还需要向上递归，继续调整，根据实际情况转化为其他 case；若这子树的根没有家长节点，则直接染黑红根即可；而倘若子树根节点的家长节点是黑节点，那么我们就调整完毕了。
		
		![](../../../assets/Pasted image 20240921144446.png)
		

总结起来，我们可以用一个状态机来概括：

![](../../../assets/Pasted%20image%2020240921144801.png)

其中 $C$ 表示染色操作，$R$ 表示旋转操作；状态机中的**粗线**表示转换过程中，我们关注的“子树”向上攀升了一级；而**细线**表示我们关注的子树仍然是这一层的那一棵。