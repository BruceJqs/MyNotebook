---
hide:
  #- navigation # 显示右
  #- toc #显示左
  - footer
  - feedback
comments: true
--- 

# Chapter 14 : Concurrency Control

## Lock-Based Protocols

一种确保隔离性的方法是要求被访问的数据项遵循一种相互排斥的规则：当某个事务访问数据项时，其他事务就不得修改这个数据项。实现这种要求的最常用的方法是仅允许对于数据项有**锁**（Lock）的事务访问该数据项。一般会提供多种锁模式，我们目前只关注这两种：

- **共享**（Shared）：若事务 $T_i$​ 获得一个对于数据项 $Q$ 的**共享锁**（Shared-Mode Lock）（记作 $S$），那么 $T_i$​ 可以读取 $Q$，但不能向 $Q$ 写入
- **排他**（Exclusive）：若事务 $T_i$​ 获得一个对于数据项 $Q$ 的**排他锁**（Exclusive-Mode Lock）（记作 $X$），那么 $T_i$​ 可以读取并写入 $Q$

当事务访问数据项时，它会向并发控制管理器发起合适的**请求**（Request）；只有当并发控制管理器向事务**授予**（Grant）锁时，该事务才能继续后面的操作

这两种锁模式允许多个事务读取同一个数据项，但也给出了一次仅允许一个事务进行写访问的限制。我们可以用一个**兼容性函数**（Compatibility Function）来描述这一特征：假如有两个任意的锁模式 $A,B$，如果在数据项 $Q$ 已经有锁模式 $B$ 的情况下，事务 $T_i$​ 仍然能够被立即授予对于该数据项的锁模式 $A$，那么称模式 $A$ 和模式 $B$ 是**兼容的**（Compatible）。兼容性函数 `comp(A, B)` 可以用以下表格描述（值为 true 表明是兼容的）：

|     | $S$   | $X$   |
| --- | ----- | ----- |
| $S$ | True  | False |
| $X$ | False | False |

可以看到，只有共享模式是相互兼容的，而一旦涉及到排他模式就是不兼容的

我们定义一些和锁相关的指令：

- `lock-S(Q)`：向数据项 $Q$ 发起共享锁请求
- `lock-X(Q)`：向数据项 $Q$ 发起排他锁请求
- `unlock(Q)`：解锁数据项 $Q$
    - 该指令不一定要放在事务的最后执行

要想访问数据项，事务 $T_i$​ 必须先锁住该数据项。如果该数据项已被其他事务锁住的话，并发控制管理器就不会向 $T_i$​ 授予锁，$T_i$​ 一直处于**等待**状态，直到所有不兼容的锁都被释放为止
***
### The Two-Phase Locking Protocol

一种确保（冲突）可串行性的协议是**两阶段锁协议**（Two-Phase Locking Protocol），该协议要求每个事务分两个阶段发起加锁和解锁请求：

- **增长阶段**（Growing Phase）：事务可能会获得锁，但不会释放任何锁
- **收缩阶段**（Shrinking Phase）：事务可能会释放锁，但不会获得任何新的锁

在调度中，某个事务获取最后一个锁（在增长阶段的末尾）的节点被称为该事务的**锁点**（Lock Point)。调度中的事务可以按照锁点序排序，而这样的顺序正是可串行的顺序

![](../../../assets/Pasted%20image%2020250512205432.png)

该协议不保证不会出现死锁问题，而且可能会出现**级联回滚**（Cascading Rollback）的问题。为避免该问题发生，我们对原来的协议稍作修改，得到**严格两阶段锁协议**（Strict Two-Phase Locking Protocol）。该协议在原有协议的基础上，要求事务所有的排他锁必须被保留，直到该事务被提交为止。另一种变体是**强严格两阶段锁协议**（Rigorous Two-Phase Locking Protocol），它要求保留所有锁，直至事务被提交

为了提高并发程度，我们在基础的两阶段锁协议上增加一种**锁转换**（Lock Conversion）机制，它支持：

- **升级**（Upgrade）：从共享锁到排他锁的转换，仅发生在增长阶段
- **降级**（Downgrade）：从排他锁到共享锁的转换，仅发生在收缩阶段

需要注意的是，当数据项 $Q$ 被其他事务以共享模式锁住时，尝试升级对 $Q$ 的锁的事务会被要求强制等待