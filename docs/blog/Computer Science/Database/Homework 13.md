---
hide:
  #- navigation # 显示右
  #- toc #显示左
  - footer
  - feedback
comments: true
--- 

# Homework 13

## 17.6

> Consider the precedence graph of Figure 17.16. Is the corresponding schedule conflict serializable? Explain your answer.
> 
> ![](../../../assets/Pasted%20image%2020250512211557.png)

这个调度是冲突可序列化的，因为整个图是无环图，它的拓扑排序 $T_1,T_2,T_3,T_4,T_5$ 即为答案
***
## 17.7

> What is a cascadeless schedule? Why is cascadelessness of schedules desirable? Are there any circumstances under which it would be desirable to allow noncascadeless schedules? Explain your answer.

无级联调度指的是如果事务 $T_j$​ 要读取事务 $T_i$​ 修改过的数据项，那么必须等到事务 $T_i$​ 提交（Commit）之后，事务 $T_j$​ 才能读取该数据项

无级联调度的可取性主要体现在以下几个方面：

1. **避免级联回滚**：级联回滚会导致大量已完成的工作被撤销，浪费系统资源（如CPU时间），并可能显著延迟其他事务的执行。无级联调度通过确保事务只读取已提交的数据，从根本上消除了发生级联回滚的可能性。一旦某个事务失败并回滚，它不会影响到其他已经读取其修改的事务，因为根据定义，其他事务必须等待它提交后才能读取
2. **保证数据一致性**：由于事务只能读取已提交的、被认为是持久和正确的数据，这有助于维护数据库的一致性。如果允许读取未提交的数据，一旦写入该数据的事务中止，那么读取了这些脏数据的事务就会基于不正确的数据进行操作，可能导致数据库进入不一致状态
3. **简化恢复过程**：当发生事务故障时，恢复管理器的工作会更加简单。由于不存在级联回滚，系统只需要回滚失败的事务本身，而不需要追踪并回滚那些依赖于该失败事务的其它事务。这使得恢复过程更快、更高效
4. **提高可靠性**：通过防止级联回滚和确保数据一致性，无级联调度增强了整个数据库系统的可靠性和健壮性

在以下情况下会考虑非无级联调度：

- **追求更高的并发度**：无级联调度的限制（即事务必须等待另一个事务提交后才能读取其修改的数据）可能会降低系统的并发性能
- **故障发生概率极低**：如果系统环境非常稳定，事务失败的概率非常小，那么因级联回滚而付出的代价可能偶尔才会发生。在这种情况下，为了获得更高的并发度所带来的性能提升，承担偶尔发生级联回滚的风险可能是可以接受的

