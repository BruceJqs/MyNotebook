---
hide:
  #- navigation # 显示右
  #- toc #显示左
  - footer
  - feedback
comments: true
---  
# Chapter 4 : The Processors

## Introduction

- CPU 性能因素
	- 指令数：由 ISA 和编译器决定
	- CPI 和 Cycle Time：由 CPU 硬件决定
***
### Instruction Execution Overview

- 对于每一个指令，从内存中取指和译码指令是两个最重要的事情
	- 取指：将带有编码的 PC（程序计数器）发给内存，从而得到内存中的指令
	- 译码：根据指令的特定字段，读取一到二个寄存器内的数据（除了`ld`指令只需一个寄存器外，其他大多数指令需要两个寄存器）
- 最简单的 CPU 需要实现如下指令：
	- 内存引用指令：`ld, sd...`
	- 算术逻辑指令：`add, sub, and, or...`
	- 条件分支指令：`beq...`
- 接下来根据指令集来进行如下操作：
	- 执行：使用 ALU 来进行数学逻辑运算、存取数据（地址运算，加法）、条件分支（判断条件，减法）
	- 写回/访存：访问内存（加载 $\rightarrow$ 读取数据，存储 $\rightarrow$ 写下数据）、将 ALU 或内存中的数据写入寄存器中、根据比较结果改变下一条需要执行的指令的地址（可能是 PC+4，也可能是指定的指令地址）
***
### An Overview of Implementation

![](../../../assets/Pasted%20image%2020241028132827.png)

使用多路选择器的原因（顺序为从上到下）：

- 对于第一个多路选择器，我们需要选择下一条需要执行的指令到底是按照顺序的下一个指令（PC+4）还是因为跳转的某个指定的指令
- 对于第二个多路选择器，我们需要选择进行运算的数据是来自于 ALU 运算的结果还是内存中的数据
- 对于第三个多路选择器，对于不同类型的指令，ALU 需要选择运算数是来自寄存器（例如 R 型指令）还是立即数（例如 I 型指令）

那么对于多路选择器，我们也需要一个控制单元来决定选择哪个来源，而控制单元是根据输入的指令来作判断的。此外，控制单元还负责功能的控制，比如寄存器和内存的读写、是否进行分支操作等。最后整个大致图如下：

![](../../../assets/Pasted%20image%2020241028133331.png)

- 其中对于 Branch 只有当 ALU 输出为 0 控制单元为 1 时，表示为跳转地址，下一个要执行的指令即为指定的地址

## Logic Design Convention

对于以上所出现的各类元件，我们可以分类如下：

- 组合元件：ALU，MUX 等
- 状态（时序）元件：内存、寄存器等

## Building a Datapath

!!! Definition

	Datapath（数据通路）即为 CPU 中处理数据和地址的元件
	
	e.g. 寄存器、ALU、多路选择器、内存...

### Instruction Execution in RISC-V

- 取指：
	- 从指令内存中获取指令
	- 将 PC 寄存器指向下一条指令
- 译码 & 读取运算数
	- 指令将会被译码为机器控制指令
	- 从寄存器中读取运算数
- 执行控制：
	- 控制对应 ALU 操作的执行
- 仿存：
	- 从内存写/读数据
	- 仅限 `ld/sd` 指令
- 将结果写至寄存器：
	- 如果是 R 型指令，将 ALU 运算结果写到 `rd` 寄存器
	- 如果是 I 型指令，将内存数据写到 `rd` 寄存器
- 改变 PC 计数器

!!! Instructions

	=== "Fetch"
	
		![](../../../assets/Pasted image 20241028142701.png)
		
		- 内存单元：存储程序的指令，并根据地址提供对应的指令
		- 程序计数器 (Program Counter)：保存当前指令的地址
		- 加法器：PC 执行加 4 操作，使其获得下一条指令的地址
	
	=== "R-Format"
	
		![](../../../assets/Pasted image 20241028142934.png)
		
		- **寄存器堆**：存储了所有的寄存器，通过指定具体的寄存器编号来控制对应寄存器的读写
			- 寄存器编号为 5 位，因为一共只有 $2^5=32$ 个寄存器
			- R 型指令需要两个可读的（源）寄存器和一个可写的（目标）寄存器
			- 读取数据只需输入寄存器编号即可，而写入数据除了额外输入写入的数据外，还要受控制信号`RegWrite`的控制，只有在`RegWrite = 1`时才可以进行写操作
		- 64 位的 ALU
			- 如果 ALU 结果为 0，输出端`Zero = 1`，否则`Zero = 0`
			- 有 1 个 4 位的 ALU 运算的控制运算操作
	
	=== "Load/Store"
	
		除了 R 型指令需要的寄存器堆和 ALU 两个元件外，存取指令还需要以下两个元件：
		
		![](../../../assets/Pasted image 20241028143242.png)
		
		- 数据内存单元
			- 内存同时具备读（`ld`）和写（`sd`）的控制输入
		- 立即数生成单元：从 32 位指令中提取出与立即数相关的位，将这些位按正确的顺序拼接起来，同时对其**符号扩展**至 64 位
	
	=== "Branch"
	
		![](../../../assets/Pasted image 20241028143521.png)
		
		- 用到的元件：寄存器堆（包含两个寄存器，表示被比较的两个数）、立即数生成器（地址偏移量）、两个 ALU（其中一个仅用于加法运算来计算跳转目标地址）
		- 该数据通路需要同时计算分支目标地址并检验寄存器内容
		- 一些细节问题：
			- 跳转地址的基 (base) 即为当前的分支指令的地址
			- 不要忘记：偏移量字段需左移一位！所以实际的偏移量是指定偏移量的两倍，且相邻偏移量相差 2
		- 我们仅用 ALU 的`Zero`输出来获取比较结果