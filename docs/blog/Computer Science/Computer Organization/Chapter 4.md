---
hide:
  #- navigation # 显示右
  #- toc #显示左
  - footer
  - feedback
comments: true
---  
# Chapter 4 : The Processors

## Introduction

- CPU 性能因素
	- 指令数：由 ISA 和编译器决定
	- CPI 和 Cycle Time：由 CPU 硬件决定
***
### Instruction Execution Overview

- 对于每一个指令，从内存中取指和译码指令是两个最重要的事情
	- 取指：将带有编码的 PC（程序计数器）发给内存，从而得到内存中的指令
	- 译码：根据指令的特定字段，读取一到二个寄存器内的数据（除了`ld`指令只需一个寄存器外，其他大多数指令需要两个寄存器）
- 最简单的 CPU 需要实现如下指令：
	- 内存引用指令：`ld, sd...`
	- 算术逻辑指令：`add, sub, and, or...`
	- 条件分支指令：`beq...`
- 接下来根据指令集来进行如下操作：
	- 执行：使用 ALU 来进行数学逻辑运算、存取数据（地址运算，加法）、条件分支（判断条件，减法）
	- 写回/访存：访问内存（加载 $\rightarrow$ 读取数据，存储 $\rightarrow$ 写下数据）、将 ALU 或内存中的数据写入寄存器中、根据比较结果改变下一条需要执行的指令的地址（可能是 PC+4，也可能是指定的指令地址）

> 注：绝大多数指令只需四步即可完成，只有加载相关的指令需要五步。
***
### An Overview of Implementation

![](../../../assets/Pasted%20image%2020241028132827.png)

使用多路选择器的原因（顺序为从上到下）：

- 对于第一个多路选择器，我们需要选择下一条需要执行的指令到底是按照顺序的下一个指令（PC+4）还是因为跳转的某个指定的指令
- 对于第二个多路选择器，我们需要选择进行运算的数据是来自于 ALU 运算的结果还是内存中的数据
- 对于第三个多路选择器，对于不同类型的指令，ALU 需要选择运算数是来自寄存器（例如 R 型指令）还是立即数（例如 I 型指令）

那么对于多路选择器，我们也需要一个控制单元来决定选择哪个来源，而控制单元是根据输入的指令来作判断的。此外，控制单元还负责功能的控制，比如寄存器和内存的读写、是否进行分支操作等。最后整个大致图如下：

![](../../../assets/Pasted%20image%2020241028133331.png)

- 其中对于 Branch 只有当 ALU 输出为 0 控制单元为 1 时，表示为跳转地址，下一个要执行的指令即为指定的地址
***
## Logic Design Convention

在计算机当中，信息被编码为二进制，低电位为 0，高电位为 1，一条线一位（bit），多条线的信息就在多线总线（bus）被编码。

对于以上所出现的各类元件，我们可以分类如下：

- 组合元件：ALU，MUX 等，处理数据，输出可视为输入的一个函数
- 状态（时序）元件：内存、寄存器等，保存信息
***
## Building a Datapath

!!! Definition

	Datapath（数据通路）即为 CPU 中处理数据和地址的元件
	
	e.g. 寄存器、ALU、多路选择器、内存...
***
### Instruction Execution in RISC-V

- 取指：根据 PC 所给地址，从存储器中取出指令
	- 从指令内存中获取指令
	- 将 PC 寄存器指向下一条指令
- 译码 & 读取运算数：分析指令字段，读取一个或两个寄存器
	- 指令将会被译码为机器控制指令
	- 从寄存器中读取运算数
- 执行控制：ALU 运算 R 型指令的结果/访存指令的地址/beq 两源操作数是否相等
	- 控制对应 ALU 操作的执行
- 访存：
	- 从内存写/读数据
	- 仅限 `ld/sd` 指令
- 将结果写至寄存器：
	- 如果是 R 型指令，将 ALU 运算结果写到 `rd` 寄存器
	- 如果是 I 型指令，将内存数据写到 `rd` 寄存器
- 改变 PC 计数器

!!! Instructions

	=== "Fetch"
	
		![](../../../assets/Pasted image 20241028142701.png)
		
		- 内存单元：存储程序的指令，并根据地址提供对应的指令
		- 程序计数器 (Program Counter)：保存当前指令的地址
		- 加法器：PC 执行加 4 操作，使其获得下一条指令的地址
	
	=== "R-Format"
	
		![](../../../assets/Pasted image 20241028142934.png)
		
		- **寄存器堆**：存储了所有的寄存器，通过指定具体的寄存器编号来控制对应寄存器的读写
			- 寄存器编号为 5 位，因为一共只有 $2^5=32$ 个寄存器
			- R 型指令需要两个可读的（源）寄存器和一个可写的（目标）寄存器
			- 读取数据只需输入寄存器编号即可，而写入数据除了额外输入写入的数据外，还要受控制信号`RegWrite`的控制，只有在`RegWrite = 1`时才可以进行写操作
		- 64 位的 ALU
			- 如果 ALU 结果为 0，输出端`Zero = 1`，否则`Zero = 0`
			- 有 1 个 4 位的 ALU 运算的控制运算操作
	
	=== "Load/Store"
	
		除了 R 型指令需要的寄存器堆和 ALU 两个元件外，存取指令还需要以下两个元件：
		
		![](../../../assets/Pasted image 20241028143242.png)
		
		- 数据内存单元
			- 内存同时具备读（`ld`）和写（`sd`）的控制输入
		- 立即数生成单元：从 32 位指令中提取出与立即数相关的位，将这些位按正确的顺序拼接起来，同时对其**符号扩展**至 64 位
	
	=== "Branch"
	
		![](../../../assets/Pasted image 20241028143521.png)
		
		- 用到的元件：寄存器堆（包含两个寄存器，表示被比较的两个数）、立即数生成器（地址偏移量）、两个 ALU（其中一个仅用于加法运算来计算跳转目标地址）
		- 该数据通路需要同时计算分支目标地址并检验寄存器内容
		- 一些细节问题：
			- 跳转地址的基 (base) 即为当前的分支指令的地址
			- 不要忘记：偏移量字段需左移一位！所以实际的偏移量是指定偏移量的两倍，且相邻偏移量相差 2
		- 我们仅用 ALU 的`Zero`输出来获取比较结果
***
### Composing the Elements

接下来我们将前面得到的数据通路元件组装起来。

基本的数据通路一个时钟周期执行一条指令，每个数据通路元件一次只能执行一个函数，因此我们需要将存储指令和存储数据的内存分开看待，由此形成指令存储器和数据存储器。

我们需要使用多路复用器，以便在不同指令中使用不同的数据源。

![](../../../assets/Pasted%20image%2020241105235921.png)

!!! note "各类指令的数据通路走向"

	=== "R-Type"
	
		- 数据通路示意图：
		
		![](../../../assets/Pasted image 20241106001131.png)
		
		- 走向示意图：
		
		![](../../../assets/Pasted image 20241106000347.png)
		
		- 大致过程：
			- 根据指令读取 `opcode` 确定指令类型为 R 型，赋值 RegWrite 为 1（即可以改变寄存器存储的值）
			- 根据指令读取 `func3, func7` ，联合 `opcode` 确定 ALU 操作类型
			- 根据指令读取 `rs1, rs2`（操作数寄存器）以及 `rd`（目标结果寄存器）
			- 两个操作数寄存器根据 ALU 操作类型进行运算
			- 得到的 ALU Result 写回目标结果寄存器当中
	
	=== "I-Type(ld)"
	
		- 数据通路示意图（这里 `rs1` 的 `bit 19-15` 指错地方了应该指向寄存器堆的 `rs1`，Memread 和 Memwrite 也打错了）：
		
		![](../../../assets/Pasted image 20241106001755.png)
		
		- 走向示意图：
		
		![](../../../assets/Pasted image 20241106000459.png)
		
		- 大致过程：
			- 根据指令读取 `opcode` 确定指令类型为 I 型，赋值 RegWrite 为 1（即可以改变寄存器存储的值），Memwrite 为 0、Memread 为 1（不需要改变内存的值，只需要读取即可）
			- 根据指令读取 `func3, func7` ，联合 `opcode` 确定 ALU 操作类型
			- 根据指令读取 `rs1`（保存基础地址的寄存器），`rd`（目标寄存器）以及立即数 `immediate`（偏移量）
			- 基础地址和偏移量根据 ALU 操作类型进行运算（在这里是执行加法运算得到真正需要加载数据的地址）
			- 根据得到的 ALU Result，找到需要加载数据的地址，在内存当中读取出数据的值
			- 把读出来的值存回到目标寄存器当中
	
	=== "S-Type"
	
		- 数据通路示意图：
		
		![](../../../assets/Pasted image 20241106004138.png)
		
		- 走向示意图：
		
		![](../../../assets/Pasted image 20241106000521.png)
		
		- 大致过程：
			- 根据指令读取 `opcode` 确定指令类型为 S 型，赋值 RegWrite 为 0（不需要改变寄存器存储的值），Memwrite 为 1、Memread 为 0（这里我们需要把值存到内存当中，所以只写不读）
			- 根据指令读取 `func3` ，联合 `opcode` 确定 ALU 操作类型
			- 根据指令读取 `rs1, rs2`（保存基础地址的寄存器和保存要存的数据的寄存器）以及立即数 `immediate`（偏移量）
			- 基础地址和偏移量根据 ALU 操作类型进行运算（在这里是执行加法运算得到真正需要保存数据的地址）
			- 将数据存储到内存当中
	
	=== "SB-Type"
	
		- 数据通路示意图：
		
		![](../../../assets/Pasted image 20241106010020.png)
		
		- 走向示意图：
		
		![](../../../assets/Pasted image 20241106000546.png)
		
		- 大致过程：
			- 根据指令读取 `opcode` 确定指令类型为 SB 型，赋值 RegWrite 为 0（不需要改变寄存器存储的值），Branch 为 1（即激活跳转模块）
			- 根据指令读取 `func3` ，联合 `opcode` 确定 ALU 操作类型
			- 根据指令读取 `rs1, rs2`（需要进行比较的两个寄存器）以及立即数 `immediate`（偏移量）
			- 需要比较的两个寄存器进行 ALU 运算（这里应当为减法判断是否为 0）
			- 从指令数据通路中得到 PC 的值，与立即数相加得到跳转地址
			- 根据 ALU 运算结果是否为 0 决定下一条应当执行哪个指令（PC+4 还是 PC+偏移量），将结果传回给 PC
	
	=== "J-Type"
	
		- 数据通路示意图：
		
		![](../../../assets/Pasted image 20241106130049.png)
		
		- 走向示意图：
		
		![](../../../assets/Pasted image 20241106000609.png)
		
		- 大致过程：
			- 根据指令读取 `opcode` 确定指令类型为 J 型，赋值 RegWrite 为 1（因为要保存 `jal` 指令的下一条指令地址给 `ra` 寄存器，方便函数执行完跳回来），Jump 为 1（激活跳转模块）
			- 根据指令读取 `rd`（下一条指令的地址）以及跳转地址偏移量 `target address`
			- 从指令数据通路中得到 PC 的值，与跳转地址偏移量相加得到跳转地址
			- 将跳转地址传回给 PC
			- 将 PC+4 存储到寄存器堆中

