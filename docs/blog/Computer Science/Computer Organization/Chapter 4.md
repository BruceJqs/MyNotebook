---
hide:
  #- navigation # 显示右
  #- toc #显示左
  - footer
  - feedback
comments: true
---  
# Chapter 4 : The Processors

## Introduction

- CPU 性能因素
	- 指令数：由 ISA 和编译器决定
	- CPI 和 Cycle Time：由 CPU 硬件决定
***
### Instruction Execution Overview

- 对于每一个指令，从内存中取指和译码指令是两个最重要的事情
	- 取指：将带有编码的 PC（程序计数器）发给内存，从而得到内存中的指令
	- 译码：根据指令的特定字段，读取一到二个寄存器内的数据（除了`ld`指令只需一个寄存器外，其他大多数指令需要两个寄存器）
- 最简单的 CPU 需要实现如下指令：
	- 内存引用指令：`ld, sd...`
	- 算术逻辑指令：`add, sub, and, or...`
	- 条件分支指令：`beq...`
- 接下来根据指令集来进行如下操作：
	- 执行：使用 ALU 来进行数学逻辑运算、存取数据（地址运算，加法）、条件分支（判断条件，减法）
	- 写回/访存：访问内存（加载 $\rightarrow$ 读取数据，存储 $\rightarrow$ 写下数据）、将 ALU 或内存中的数据写入寄存器中、根据比较结果改变下一条需要执行的指令的地址（可能是 PC+4，也可能是指定的指令地址）

> 注：绝大多数指令只需四步即可完成，只有加载相关的指令需要五步。
***
### An Overview of Implementation

![](../../../assets/Pasted%20image%2020241028132827.png)

使用多路选择器的原因（顺序为从上到下）：

- 对于第一个多路选择器，我们需要选择下一条需要执行的指令到底是按照顺序的下一个指令（PC+4）还是因为跳转的某个指定的指令
- 对于第二个多路选择器，我们需要选择进行运算的数据是来自于 ALU 运算的结果还是内存中的数据
- 对于第三个多路选择器，对于不同类型的指令，ALU 需要选择运算数是来自寄存器（例如 R 型指令）还是立即数（例如 I 型指令）

那么对于多路选择器，我们也需要一个控制单元来决定选择哪个来源，而控制单元是根据输入的指令来作判断的。此外，控制单元还负责功能的控制，比如寄存器和内存的读写、是否进行分支操作等。最后整个大致图如下：

![](../../../assets/Pasted%20image%2020241028133331.png)

- 其中对于 Branch 只有当 ALU 输出为 0 控制单元为 1 时，表示为跳转地址，下一个要执行的指令即为指定的地址
***
## Logic Design Convention

在计算机当中，信息被编码为二进制，低电位为 0，高电位为 1，一条线一位（bit），多条线的信息就在多线总线（bus）被编码。

对于以上所出现的各类元件，我们可以分类如下：

- 组合元件：ALU，MUX 等，处理数据，输出可视为输入的一个函数
- 状态（时序）元件：内存、寄存器等，保存信息
***
## Building a Datapath

!!! Definition

	Datapath（数据通路）即为 CPU 中处理数据和地址的元件
	
	e.g. 寄存器、ALU、多路选择器、内存...
***
### Instruction Execution in RISC-V

- 取指：根据 PC 所给地址，从存储器中取出指令
	- 从指令内存中获取指令
	- 将 PC 寄存器指向下一条指令
- 译码 & 读取运算数：分析指令字段，读取一个或两个寄存器
	- 指令将会被译码为机器控制指令
	- 从寄存器中读取运算数
- 执行控制：ALU 运算 R 型指令的结果/访存指令的地址/beq 两源操作数是否相等
	- 控制对应 ALU 操作的执行
- 访存：
	- 从内存写/读数据
	- 仅限 `ld/sd` 指令
- 将结果写至寄存器：
	- 如果是 R 型指令，将 ALU 运算结果写到 `rd` 寄存器
	- 如果是 I 型指令，将内存数据写到 `rd` 寄存器
- 改变 PC 计数器

!!! Instructions

	=== "Fetch"
	
		![](../../../assets/Pasted image 20241028142701.png)
		
		- 内存单元：存储程序的指令，并根据地址提供对应的指令
		- 程序计数器 (Program Counter)：保存当前指令的地址
		- 加法器：PC 执行加 4 操作，使其获得下一条指令的地址
	
	=== "R-Format"
	
		![](../../../assets/Pasted image 20241028142934.png)
		
		- **寄存器堆**：存储了所有的寄存器，通过指定具体的寄存器编号来控制对应寄存器的读写
			- 寄存器编号为 5 位，因为一共只有 $2^5=32$ 个寄存器
			- R 型指令需要两个可读的（源）寄存器和一个可写的（目标）寄存器
			- 读取数据只需输入寄存器编号即可，而写入数据除了额外输入写入的数据外，还要受控制信号`RegWrite`的控制，只有在`RegWrite = 1`时才可以进行写操作
		- 64 位的 ALU
			- 如果 ALU 结果为 0，输出端`Zero = 1`，否则`Zero = 0`
			- 有 1 个 4 位的 ALU 运算的控制运算操作
	
	=== "Load/Store"
	
		除了 R 型指令需要的寄存器堆和 ALU 两个元件外，存取指令还需要以下两个元件：
		
		![](../../../assets/Pasted image 20241028143242.png)
		
		- 数据内存单元
			- 内存同时具备读（`ld`）和写（`sd`）的控制输入
		- 立即数生成单元：从 32 位指令中提取出与立即数相关的位，将这些位按正确的顺序拼接起来，同时对其**符号扩展**至 64 位
	
	=== "Branch"
	
		![](../../../assets/Pasted image 20241028143521.png)
		
		- 用到的元件：寄存器堆（包含两个寄存器，表示被比较的两个数）、立即数生成器（地址偏移量）、两个 ALU（其中一个仅用于加法运算来计算跳转目标地址）
		- 该数据通路需要同时计算分支目标地址并检验寄存器内容
		- 一些细节问题：
			- 跳转地址的基 (base) 即为当前的分支指令的地址
			- 不要忘记：偏移量字段需左移一位！所以实际的偏移量是指定偏移量的两倍，且相邻偏移量相差 2
		- 我们仅用 ALU 的`Zero`输出来获取比较结果
***
### Composing the Elements

接下来我们将前面得到的数据通路元件组装起来。

基本的数据通路一个时钟周期执行一条指令，每个数据通路元件一次只能执行一个函数，因此我们需要将存储指令和存储数据的内存分开看待，由此形成指令存储器和数据存储器。

我们需要使用多路复用器，以便在不同指令中使用不同的数据源。

![](../../../assets/Pasted%20image%2020241105235921.png)

!!! note "各类指令的数据通路走向"

	=== "R-Type"
	
		- 数据通路示意图：
		
		![](../../../assets/Pasted image 20241106001131.png)
		
		- 走向示意图：
		
		![](../../../assets/Pasted image 20241106000347.png)
		
		- 大致过程：
			- 根据指令读取 `opcode` 确定指令类型为 R 型，赋值 RegWrite 为 1（即可以改变寄存器存储的值）
			- 根据指令读取 `func3, func7` ，联合 `opcode` 确定 ALU 操作类型
			- 根据指令读取 `rs1, rs2`（操作数寄存器）以及 `rd`（目标结果寄存器）
			- 两个操作数寄存器根据 ALU 操作类型进行运算
			- 得到的 ALU Result 写回目标结果寄存器当中
	
	=== "I-Type(ld)"
	
		- 数据通路示意图（这里 `rs1` 的 `bit 19-15` 指错地方了应该指向寄存器堆的 `rs1`，Memread 和 Memwrite 也打错了）：
		
		![](../../../assets/Pasted image 20241106001755.png)
		
		- 走向示意图：
		
		![](../../../assets/Pasted image 20241106000459.png)
		
		- 大致过程：
			- 根据指令读取 `opcode` 确定指令类型为 I 型，赋值 RegWrite 为 1（即可以改变寄存器存储的值），Memwrite 为 0、Memread 为 1（不需要改变内存的值，只需要读取即可）
			- 根据指令读取 `func3, func7` ，联合 `opcode` 确定 ALU 操作类型
			- 根据指令读取 `rs1`（保存基础地址的寄存器），`rd`（目标寄存器）以及立即数 `immediate`（偏移量）
			- 基础地址和偏移量根据 ALU 操作类型进行运算（在这里是执行加法运算得到真正需要加载数据的地址）
			- 根据得到的 ALU Result，找到需要加载数据的地址，在内存当中读取出数据的值
			- 把读出来的值存回到目标寄存器当中
	
	=== "S-Type"
	
		- 数据通路示意图：
		
		![](../../../assets/Pasted image 20241106004138.png)
		
		- 走向示意图：
		
		![](../../../assets/Pasted image 20241106000521.png)
		
		- 大致过程：
			- 根据指令读取 `opcode` 确定指令类型为 S 型，赋值 RegWrite 为 0（不需要改变寄存器存储的值），Memwrite 为 1、Memread 为 0（这里我们需要把值存到内存当中，所以只写不读）
			- 根据指令读取 `func3` ，联合 `opcode` 确定 ALU 操作类型
			- 根据指令读取 `rs1, rs2`（保存基础地址的寄存器和保存要存的数据的寄存器）以及立即数 `immediate`（偏移量）
			- 基础地址和偏移量根据 ALU 操作类型进行运算（在这里是执行加法运算得到真正需要保存数据的地址）
			- 将数据存储到内存当中
	
	=== "SB-Type"
	
		- 数据通路示意图：
		
		![](../../../assets/Pasted image 20241106010020.png)
		
		- 走向示意图：
		
		![](../../../assets/Pasted image 20241106000546.png)
		
		- 大致过程：
			- 根据指令读取 `opcode` 确定指令类型为 SB 型，赋值 RegWrite 为 0（不需要改变寄存器存储的值），Branch 为 1（即激活跳转模块）
			- 根据指令读取 `func3` ，联合 `opcode` 确定 ALU 操作类型
			- 根据指令读取 `rs1, rs2`（需要进行比较的两个寄存器）以及立即数 `immediate`（偏移量）
			- 需要比较的两个寄存器进行 ALU 运算（这里应当为减法判断是否为 0）
			- 从指令数据通路中得到 PC 的值，与立即数相加得到跳转地址
			- 根据 ALU 运算结果是否为 0 决定下一条应当执行哪个指令（PC+4 还是 PC+偏移量），将结果传回给 PC
	
	=== "J-Type"
	
		- 数据通路示意图：
		
		![](../../../assets/Pasted image 20241106130049.png)
		
		- 走向示意图：
		
		![](../../../assets/Pasted image 20241106000609.png)
		
		- 大致过程：
			- 根据指令读取 `opcode` 确定指令类型为 J 型，赋值 RegWrite 为 1（因为要保存 `jal` 指令的下一条指令地址给 `ra` 寄存器，方便函数执行完跳回来），Jump 为 1（激活跳转模块）
			- 根据指令读取 `rd`（下一条指令的地址）以及跳转地址偏移量 `target address`
			- 从指令数据通路中得到 PC 的值，与跳转地址偏移量相加得到跳转地址
			- 将跳转地址传回给 PC
			- 将 PC+4 存储到寄存器堆中
***
## A Simple Implementation Scheme

>因为所有的信息（操作类型、数据去向等）都来自 32 位的指令，所以我们需要一个控制器（相当于是中枢）来将 32 位的指令处理成相对应的信号。

### Building Controller

#### ALU Symbol & Control

在所有的 8 个控制信号中，最重要的是 ALU 的控制信号（即上图的 `ALU operation` ），因为不管何种指令都需要用到这个元件，而且不同的指令会利用它达到不同的目的。

ALU 控制信号一共有 4 位：

- 其中 2 位分别来自指令中的 `funct3` 和 `funct7` 字段
- 另外 2 位则来自一个称为 `ALUOp` 的字段，它来自主控制单元 (Main Control Unit)，用于指定具体执行何种指令，不同的值对应不同的类型：
	- `00`：加载 / 存储
	- `01`：`beq` 指令
	- `10`：R 型指令

下表展示了 ALU 控制信号及对应的操作：

| **Opcode** | **ALUOp** |  **Operation**  | **Func7** | **Func3** | **ALU Function** | **ALU Control** |
|:----------:|:---------:|:---------------:|:---------:|:---------:|:----------------:|:---------------:|
|     ld     |    00     |  Load Register  |  XXXXXXX  |    XXX    |     Addition     |      0010       |
|     sd     |    00     | Store Register  |  XXXXXXX  |    XXX    |     Addition     |      0010       |
|    beq     |    01     | Branch On Equal |  XXXXXXX  |    XXX    |   Subtraction    |      0110       |
|   R-Type   |    10     |       And       |  0000000  |    111    |       And        |      0000       |
|   R-Type   |    10     |       Or        |  0000000  |    110    |        Or        |      0001       |
|   R-Type   |    10     |       Add       |  0000000  |    000    |     Addition     |      0010       |
|   R-Type   |    10     |       Sub       |  0100000  |    000    |   Subtraction    |      0110       |
|   R-Type   |    10     |       Slt       |  0000000  |    010    |       Slt        |      0111       |
|   R-Type   |    10     |       Srl       |  0000000  |    101    |       Srl        |      0101       |
|   R-Type   |    10     |       Xor       |  0000000  |    011    |       Xor        |      0011       |

其对应的真值表如下（x 表示 Don't Care 项）：

![](../../../assets/Pasted%20image%2020241110171206.png)

可以看到，我们并没有用主控制单元来直接控制所有需要控制的元件，比如用 ALU 控制（`ALUOp`）来控制 ALU，再由主控制单元改变 `ALUOp` 的值——这样的设计风格称为**多级控制**（Multiple Levels of Control），它的优势在于：

- 减小主控制单元的规模
- 减小对控制单元的潜在危害（负责某个功能的控制单元坏掉了并不会影响其他的控制单元），这对时钟周期有很大的影响
***
#### Signals For Datapath

接下来，我们还要处理剩余的 7 个控制信号，它们的作用如下：

![](../../../assets/Pasted%20image%2020241110175311.png)

- `RegWrite`、`MemRead`、`MemWrite`：它们在低电平的时候均无作用，高电平时会允许寄存器 / 内存的读写
- `ALUSrc`：低电平时 ALU 获取第 2 个寄存器的值，高电平时 ALU 获取立即数
- `PCSrc`：低电平时 PC 将会保存下一条连续指令的地址（PC + 4），高电平时 PC 将会保存分支目标地址
- `Jump`：低电平时 PC 将会保存 PC+4 或其他分支目标，高电平时 PC 将会保存跳转目标地址
- `MemtoReg`：低电平时将 ALU 的结果返回给目标寄存器，高电平时将内存中的数据传给目标寄存器

最后，我们将所有的控制信号交给主控制单元管理，一个完整的简易版单周期 CPU 的硬件框图如下所示：

![](../../../assets/Pasted%20image%2020241110172113.png)

对应的控制信号表（输入为 `Opcode` 的前 7 位）：

| **Input or Output** | **Signal Name** | **R-Format** | **ld** | **sd** | **beq** | **jal** |
|:-------------------:|:---------------:|:------------:|:------:|:------:|:-------:|:-------:|
|        Input        |      I[6]       |      0       |   0    |   0    |    1    |    1    |
|        Input        |      I[5]       |      1       |   0    |   1    |    1    |    1    |
|        Input        |      I[4]       |      1       |   0    |   0    |    0    |    0    |
|        Input        |      I[3]       |      0       |   0    |   0    |    0    |    1    |
|        Input        |      I[2]       |      0       |   0    |   0    |    0    |    1    |
|        Input        |      I[1]       |      1       |   1    |   1    |    1    |    1    |
|        Input        |      I[0]       |      1       |   1    |   1    |    1    |    1    |
|       Output        |     ALUSrc      |      0       |   1    |   1    |    0    |    X    |
|       Output        |    MemtoReg     |      00      |   01   |   X    |    X    |   10    |
|       Output        |    RegWrite     |      1       |   1    |   0    |    0    |    1    |
|       Output        |     MemRead     |      0       |   1    |   0    |    0    |    0    |
|       Output        |    MemWrite     |      0       |   0    |   1    |    0    |    0    |
|       Output        |     Branch      |      0       |   0    |   0    |    1    |    0    |
|       Output        |     ALUOp1      |      1       |   0    |   0    |    0    |    X    |
|       Output        |     ALUOp0      |      0       |   0    |   0    |    1    |    X    |
|       Output        |      Jump       |      0       |   0    |   0    |    0    |    1    |

得到逻辑电路图：

![](../../../assets/Pasted%20image%2020241110175731.png)
***
### Operation of the Datapath

> 图中的灰色部分表示没有用到的部分

!!! note "Operation of the Datapath"

	=== "R-Type"
	
		- 以 `add x1, x2, x3` 为例：
		
		![](../../../assets/Pasted image 20241110231941.png)
		
		- 执行指令的步骤：
		
			- 从指令内存中获取指令，并递增 PC
			- 从寄存器堆读取寄存器 `x2` 和 `x3`，同时主控制单元设置好对应的控制信号
			- ALU 根据操作码确定运算类型，然后对上步中读取的数据进行计算
			- 将 ALU 的计算结果写入目标寄存器 `x1`
	
	=== "Load"
	
		- 以 `ld x1, offset(x2)` 为例：
		
		![](../../../assets/Pasted image 20241110232133.png)
		
		- 执行指令的步骤：
		
			- 从指令内存中获取指令，并递增 PC
			- 从寄存器堆读取寄存器 `x2` 
			- ALU 计算寄存器 `x2` 的数据和符号扩展后的12位立即数之和，该结果作为数据的内存地址
			- 将对应的内存数据写入寄存器堆内（`x1`）
	
	=== "Store"
	
		- 以 `sd x1, offset(x2)` 为例：
		
		![](../../../assets/Pasted image 20241110232908.png)
		
		- 执行指令的步骤：
		
			- 从指令内存中获取指令，并递增 PC
			- 从寄存器堆读取寄存器 `x2` 
			- ALU 计算寄存器 `x2` 的数据和符号扩展后的12位立即数之和，该结果作为数据的内存地址
			- 将 `x1` 中的值存入对应的内存数据中
	
	=== "Branch"
	
		- 以 `beq x1, x2, offset` 为例：
		
		![](../../../assets/Pasted image 20241110232430.png)
		
		- 执行指令的步骤：
		
			- 从指令内存中获取指令，并递增 PC
			- 从寄存器堆读取寄存器 `x1` 和 `x2`
			- ALU 将读取的两个数据相减；同时将 PC 的值与左移 1 位之后的立即数相加，得到分支目标地址
			- 通过 ALU 的`Zero`信号来决定如何更新 PC
	
	=== "Jump"
	
		- 以 `jal x1, procedure` 为例：
		
		![](../../../assets/Pasted image 20241110233227.png)
		
		- 执行指令的步骤：
		
			- 从指令内存中获取指令，并递增 PC
			- 将目标地址符号扩展
			- 将地址左移一位
			- 将结果加到 PC 当中，更新 PC

总结来说，不同类型的执行步骤如下表：

| **类型** | 取指                      | 译码              | 执行     | 访存          | 写回           |
| ------ | ----------------------- | --------------- | ------ | ----------- | ------------ |
| R-Type | 根据 PC 提供的地址，从指令存储器中取出指令 | 取 `rs1` 和 `rs2` | 逻辑运算   | /           | 将运算结果写回 `rd` |
| Load   | 根据 PC 提供的地址，从指令存储器中取出指令 | 取 `rs` 和扩展后的立即数 | 计算内存地址 | 读数据存储器，取得数据 | 将访存数据写回寄存器堆  |
| Store  | 根据 PC 提供的地址，从指令存储器中取出指令 | 取 `rs` 和扩展后的立即数 | 计算内存地址 | 写数据存储器      | /            |
| Branch | 根据 PC 提供的地址，从指令存储器中取出指令 | 取 PC 和分支偏移量     | 比较     | 地址写回 PC     | /            |
| Jump   | 根据 PC 提供的地址，从指令存储器中取出指令 | 取 PC 和扩展后的目标地址  | 计算内存地址 | 地址写回 PC     | /            |

可以看到，在单周期实现中：

- 每条指令都在一个时钟周期内完成，$CPI=1$
- 时钟周期取决于最长指令的执行时长（`ld` 指令使用全部 5 个阶段，其他指令虽然只用 4 个阶段，但仍然要花费5个阶段的时间）
***
## An Overview of Pipelining

根据以上描述的，我们可以发现，因为规定每个时钟周期的长度一致，而时钟周期又取决于最长通路的执行时长（`ld` 指令需要 5 个阶段的执行时长）因此这样的 CPU 是十分低效的。

改进的方法是用流水线（Pipelining）的思想，所谓**流水线**，就是一种使多条指令能够被重叠执行的实现技术，类似工厂里的组装线。

!!! Example "类比"

	假设我们要洗一堆脏衣服，将这件事分为四个步骤：用洗衣机洗、用烘干机烘干、折叠衣物、放入衣柜，假定这四个步骤所花的时间是一样的。现在有四堆脏衣服要洗，如果一个时间段只完成一个步骤，那么整个过程如下所示（耗时为 16）：
	
	![](../../../assets/Pasted image 20241111101601.png)
	
	但如果我们采用流水线的思想来洗这四堆衣物，那么整个过程所花的时间就会显著缩短（耗时为 7）：
	
	![](../../../assets/Pasted image 20241111101638.png)
	
	可以发现，对于单个工作，流水线技术并没有缩短其运行时间；但是由于多个工作可以并行地执行，流水线技术可以更好地压榨资源，使得它们被同时而不是轮流使用，在工作比较多的时候可以增加整体的 **吞吐率**（Throughput），从而减少了完成整个任务的时间。
	
	- 由于流水线开始和结束的时候并没有完全充满，开头和结尾部分的阶段仅执行部分任务（即整个系统没有满负荷运载），因此吞吐率不及原来的 4 倍（4 来自于例子中有 4 个步骤）；但是当工作数足够多的时候，吞吐率就几乎是原来的 4 倍了。

在 RISC-V 中，为了实现流水线指令的执行，需要将单个 RISC-V 指令划分为 5 个阶段：

- **IF（取指，Instruction Fetch）**：从内存中获取指令
- **ID（译码，Instruction Decode）**：读取寄存器，对指令进行译码
- **EX（执行，Execute）**：执行（算术 / 逻辑）运算或计算地址
- **MEM（访存，Memory）**：从数据内存中访问操作数
- **WB（写回，Write Back）**：将结果写回寄存器中

用图形符号来表示这五个阶段：

![](../../../assets/Pasted%20image%2020241111102151.png)

- 图形的左半边阴影表示写入，右半边阴影表示读取，全阴影表示两者皆有
- 之所以如此规定，是因为这里假设在一个时钟周期内，元件的前半个周期可以进行**写**操作，后半个周期可以进行**读**操作

本章讨论的流水线 CPU 均为这种五级流水线 CPU，即单个时钟周期内至多能并行执行五个阶段的 CPU。