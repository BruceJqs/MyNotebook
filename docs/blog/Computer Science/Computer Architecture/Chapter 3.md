---
hide:
  #- navigation # 显示右
  #- toc #显示左
  - footer
  - feedback
comments: true
--- 

# Chapter 03 : Instruction-Level Parallelism (ILP)

!!! abstract "Abstract"

	 在计组我们学习的流水线 CPU 仅仅只是考虑了整数指令的操作，且默认每次操作需要一个时钟周期，那对于浮点数的操作呢？浮点数操作所需要的时间远比整数操作时间大，那么当我们添加浮点数操作时，是该使用一个更慢的时钟？还是去各种优化浮点数模块呢？

## Multicycle FP Operation

- 浮点数流水线
	- 允许对于一次操作更长的时延，例如，对于 EXE 模块用大于 1 个时钟周期的时间来完成操作
	- 在整数流水线上的两个改变：
		- 重复使用 EXE 模块
		- 使用多样的浮点数函数单元（比如浮点数加法器，浮点数除法）

![](../../../assets/Pasted%20image%2020250406222844.png)

可以看到，EX 模块并没有使用流水线的方式执行：

- 直到前一条指令离开 EX 模块，不能发起（Issue）使用该功能单元的其他指令
- 如果有一条指令没法前进到 EX 模块，在这条指令之后整个流水线都会停顿
***
## Latency & Ini/Repeat Interval

- 时延（Latency）：产生结果的指令和使用结果的指令之间需要的时钟周期数
- 初始化/重复间隔（Initiation/Repeat Interval）：发出给定类型的两个操作之间必须经过的时钟周期数

各个功能单元的时延和初始化/重复间隔如下：

![](../../../assets/Pasted%20image%2020250406224119.png)

一些解释：

- 对于我们学习过的整数 ALU，因为有 Forwarding 的存在，所以时延为 0

![](../../../assets/Pasted%20image%2020250406225546.png)

- 对于数据存储器来说，即 Load-Use Hazard 的情况，必须加一个停顿周期，所以时延为 1

![](../../../assets/Pasted%20image%2020250406225658.png)

- 当连续两个指令都是 Load 指令时，第二个 Load 指令必须等第一个 Load 指令完成才能执行，所以重复间隔为 1

![](../../../assets/Pasted%20image%2020250406225831.png)

特别需要注意的是：流水线的时延永远比执行模块到产生结果的时钟周期数要小 1 个时钟周期

![](../../../assets/Pasted%20image%2020250406230021.png)
***
## Structural Hazard

在加入浮点数操作之后，就会造成一个新的问题，因为不同的浮点数操作并不完全是流水线式的，且需要的时钟周期也不同，这会导致有可能会出现在同一个时钟周期出现不止一次的寄存器写操作，这就造成了结构冒险（Structural Hazard）

![](../../../assets/Pasted%20image%2020250406230427.png)

- 解决方法——联锁检测（Interlock Detection）：
	- 方法一：在译码阶段就记录写端口的使用情况，并在指令发起之前停顿一个周期
		- 移位寄存器记录何时已发起的指令将使用寄存器堆
		- 如果在译码阶段有指令需要使用寄存器堆，则停顿一个周期
	- 方法二：当指令要进入 MEM/WB 模块时，停顿这个指令
		- 可以停顿正在发起或者已经发起的指令
		- 给最长时延单元最高的优先级
		- 更复杂情况是，在两个地方都需要停顿
***
## WAW Hazard

不仅仅是结构冒险，由于指令并不是按照指令的既定顺序到达 WB 模块了，所以就会出现 WAW 冒险（Write After Write Hazard），即两个指令都要写入同一个寄存器，但是第二条指令在第一条指令之前到达了 WB 模块

![](../../../assets/Pasted%20image%2020250406231750.png)

- 解决方法：
	- 方法一：延后 fld 指令的发起
	- 方法二：fadd.d 的零写入控制
***
## RAW Hazard

RAW 冒险（Read After Write Hazard）就是和我们的 Load-Use 冒险同理，只是因为加入了浮点数操作，所以会造成更多更复杂的情况

![](../../../assets/Pasted%20image%2020250406233128.png)

![](../../../assets/Pasted%20image%2020250406233152.png)
***
## Hazard: Exceptions

由于不同浮点数操作需要的时钟周期不同，所以一系列指令的结束顺序很可能和发起顺序不同，这就会造成异常（Exception）

### Hazard Detection in ID

- 检查结构冒险
	- 确保当寄存器写端口被需要时是可用的
	- 直到需要的功能单元不忙碌时再做（仅限除法）
- 检查 RAW 数据冒险
	- 直到源寄存器在需要时可用再做——当它们不是已发起指令的待处理目标时
- 检查 WAW 冒险
	- 检查任何 A1-A4，D，M1-M7 中的指令是否有和当前指令相同的目的寄存器
	- 如果有，则停顿当前指令在 ID 阶段的发起
***
### Forwarding

因为数据冒险更为多样复杂了，Forwarding 的情况也变得更多了（EX/MEM, A4/MEM, M7/MEM, D/MEM, MEM/WB）
***
### Out-of-Order Completion

指令结束的顺序不同的解决方法有：

- 直接忽略
- 将指令的结果写入缓冲器中，直到其他比当前指令先发起的指令完成
- 记录流水线当中执行的指令和它们的 PC
- 只有确认所有之前的指令完成时不会造成异常，才发起指令


