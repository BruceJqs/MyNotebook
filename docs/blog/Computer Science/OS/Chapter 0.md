# Chapter 0: Introduction

## Computer System Firmware

计算机系统可以分为四个组成部分：

- 硬件——提供基本的计算资源：CPU、内存、输入/输出设备
- 操作系统：控制和协调硬件在各种应用和用户之间的使用
- 系统程序和应用程序——定义系统资源的使用方式，以解决用户的计算问题：文字处理器、编译器、网页浏览器、数据库系统、视频游戏
- 用户：人、机器、其他计算机

它们之间的关系主要如下图所示：

![](../../../assets/Pasted%20image%2020250917102252.png)
***
## Operating System Definition

- 操作系统是一个充当计算机用户与计算机硬件之间中介的程序，它是资源分配者，管理所有资源，在相互冲突的请求之间进行决策，以实现高效和公平的资源使用；它也是控制程序，控制程序的执行，以防止错误和不当使用计算机
- 操作系统的目标：
    - 执行用户程序，并使解决用户问题变得更容易
    - 帮助计算机用户以高效的方式利用计算机硬件
- “计算机上始终在运行的那个程序”就是内核（Kernel）。其他的要么是系统程序（随操作系统一起提供），要么是应用程序。
***
## Computer Startup

在启动一个计算机时，通常会经过以下两步：

1. 引导程序（Bootstrap Program）在开机或重启时加载
	- 引导程序通常存储在只读存储器（ROM）或可擦可编程只读存储器（EPROM）中，一般称为固件（Firmware）
	- 它初始化系统的各个方面，加载操作系统内核并开始执行
2. 计算机系统开始运行
	- 一个或多个 CPU，设备控制器通过共有总线连接，实现对共享内存的访问（如下图所示）
	- CPU 与设备并发执行，争夺内存周期
	
	![](../../../assets/Pasted%20image%2020250917103112.png)
	
	- I/O 设备和 CPU 可以并发执行
	- 每个设备控制器负责一种特定类型的设备
	- 每个设备控制器都有一个本地缓冲区（Local Buffer）
	- CPU 将数据从主存储器移动到本地缓冲区，或从本地缓冲区移动到主存储器
	- I/O 操作是指从设备到控制器本地缓冲区的数据传输
	- 设备控制器通过引发中断（通过系统总线）来通知 CPU 其操作已经完成
***
### I/O Structure

在 I/O 开始后，只有当 I/O 完成时，控制权才会返回到用户程序。

- 等待指令会让 CPU 处于空闲状态，直到下一个中断发生
- 等待循环（会导致内存访问竞争）
- 一次最多只能有一个 I/O 请求处于未完成状态，无法同时进行多个 I/O 处理

在 I/O 开始后，控制权会立即返回给用户程序，而无需等待 I/O 完成

- 系统调用（System Call）——请求操作系统允许用户等待 I/O 完成
- 设备状态表（Device-Status Table）包含每个 I/O 设备的条目，显示其类型、地址和状态
- 操作系统通过索引 I/O 设备表来确定设备状态，并可修改表项以包含中断信息

I/O 主要有异步和同步两种方式，如下图所示：

![](../../../assets/Pasted%20image%2020250917105629.png)
***
### Interrupt Handling

如果遇到了中断情况：

- 中断会将控制权转移到中断服务程序，通常是通过中断向量（Interrupt Vector），其中包含所有服务程序的地址
- 中断架构必须保存被中断指令的地址
- 当另一个中断正在处理时，会禁止新的中断进入，以防止丢失中断（Lost Interrupt）
- 陷阱（Trap）是由软件生成的中断，可能是由于错误（Error）或用户请求（User Request）（后者通常称为系统调用，System Call）引发的
- 一个操作系统是由中断驱动的（Interrupt Driven），操作系统通过寄存器（Registers）和程序计数器（Program Counter），来保护 CPU 的状态
- 要判断发生了哪种类型的中断：
	- 通过通用例程轮询（Polling）
	- 向量化中断系统（Vectored Interrupt System）
- 不同的代码片段决定了针对每种类型的中断应采取什么操作

![](../../../assets/Pasted%20image%2020250917104155.png)
***
## Direct Memory Access Structure

- 用于能够以接近内存速度传输信息的高速 I/O 设备
- 设备控制器将数据块从缓冲存储区直接传输到主存，而无需 CPU 干预
- 每处理一个数据块只会产生一个中断，而不是每处理一个字节就产生一个中断
***
## Operating System Structure

操作系统主要采取多程序设计（Multiprogramming），主要是为了提高效率（CPU 利用率）

- 单用户无法时刻让 CPU 和 I/O 设备都处于工作状态
- 多道程序设计将作业（代码和数据）组织起来，保证 CPU 始终有事情可做
- 系统中的部分作业被保存在内存中
- 通过作业调度（Job Scheduling）选择并运行一个作业
- 当一个作业需要等待（比如 I/O 操作）时，操作系统会切换到其它作业

分时/多任务（Timesharing / Multitasking）是多道程序设计的逻辑扩展，CPU 在各作业间频繁切换，使得用户可以与正在运行的每个作业交互，实现交互式计算（Interactivity）。

- 响应时间（Response Time）应小于 1 秒
- 每个用户在内存中至少有一个正在执行的程序→进程（Process）
- 如果有多个作业同时准备就绪运行→需要 CPU 调度（CPU Scheduling）
- 如果进程装不下内存，交换（Swapping）可以将它们调进调出以运行
- 虚拟内存（Virtual Memory）允许进程在未完全装入内存的情况下执行