---
hide:
  #- navigation # 显示右
  #- toc #显示左
  - footer
  - feedback
# comments: true
---  

# Meltdown Attack

## 任务 1：从缓存读取数据与从内存读取数据的比较

编译代码并运行，如下图所示：

![](../../../../../assets/Pasted%20image%2020250825231721.png)

可以看到，我们在程序中设置预先缓存的 `array[3*4096]` 和 `array[7*4096]` 访问时间明显比其他元素要快，大致是以 100ns 为界限
***
## 任务 2：使用缓存作为侧信道

编译代码并运行，如下图所示：

![](../../../../../assets/Pasted%20image%2020250826114257.png)

可以看到，程序成功得到了 Secret 94
***
## 任务 3：在内核空间放置秘密数据

编译代码，并将其内核模块安装到内核当中：

![](../../../../../assets/Pasted%20image%2020250826114743.png)

我们可以得知，秘密数据的地址位于 `0xb8d3cece`
***
## 任务 4：从用户空间获取内核内存

编写代码如下：

![](../../../../../assets/Pasted%20image%2020250826115501.png)

尝试编译运行代码，结果如下：

![](../../../../../assets/Pasted%20image%2020250826115430.png)

可以看到，程序在运行 `char kernel_data = *kernel_data_addr;` 语句时出现了段错误（Segmentation Fault），这是因为我们尝试访问内核空间的内存地址，操作系统阻止了这种非法访问
***
## 任务 5：C 语言处理错误/异常

将代码中的秘密地址修改，编译并运行代码，结果如下：

![](../../../../../assets/Pasted%20image%2020250826115821.png)

可以看到，程序成功处理了段错误，并继续执行了程序
***
## 任务 6：CPU 中的乱序执行

修改代码中的秘密地址，编译并运行代码，结果如下：

![](../../../../../assets/Pasted%20image%2020250826120412.png)

可以看到，我们成功得到了 Secret 7
