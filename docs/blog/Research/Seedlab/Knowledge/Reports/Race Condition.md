---
hide:
  #- navigation # 显示右
  #- toc #显示左
  - footer
  - feedback
# comments: true
---  

# Race Condition

## 任务 1：选择我们的目标

手动更改 `/etc/passwd` 文件的内容，添加 test 账户的条目，切换用户并查看权限：

![](../../../../../assets/Pasted%20image%2020250721200429.png)

可以看到，我们成功添加了一个 test 用户，并且拥有了 Root 权限。
***
## 任务 2：启动竞态条件攻击

### 任务 2.A：模拟一个慢速机器

我们在 access 和 open 函数中添加一个 `sleep(10)` 函数来模拟一个慢速机器，重新编译代码，并在这 10 秒内将 `/tmp/X` 文件指向 `/etc/passwd` ，并输入 test 账户的条目

![](../../../../../assets/Pasted%20image%2020250721204848.png)

![](../../../../../assets/Pasted%20image%2020250721204831.png)

运行结束之后，我们再次验证 test 用户和权限：

![](../../../../../assets/Pasted%20image%2020250721204922.png)

可以看到，我们同样还是获得了一个 test 用户并获得了 Root 权限
***
### 任务 2.B：真正的攻击

编写一个程序来反复更改 `/tmp/X` 文件的指向并编译运行：

![](../../../../../assets/Pasted%20image%2020250721210401.png)

![](../../../../../assets/Pasted%20image%2020250721210526.png)

更改 Shell 脚本的输入并运行脚本：

![](../../../../../assets/Pasted%20image%2020250721210457.png)

运气比较好，成功修改了 passwd 文件，并登录 test 用户得到 Root 权限：

![](../../../../../assets/Pasted%20image%2020250721210717.png)
***
### 任务 2.C：一种改进的攻击方法

我们修改攻击程序：

![](../../../../../assets/Pasted%20image%2020250721212638.png)

重新运行攻击程序与脚本：

![](../../../../../assets/Pasted%20image%2020250721220126.png)

可以看到攻击成功
***
## 任务 3：防护措施

### 任务 3.A：应用最小权限原则

更改 vulp.c 如下，在 access 之后 open 之前改变 effective user id：

![](../../../../../assets/Pasted%20image%2020250721222101.png)

重新编译代码并进行攻击，运行非常久后仍然显示 No permission，这是因为我们在 access 函数执行后已经将 effective user id 改为实际用户 id，因此就算成功利用了漏洞也无法访问 `/etc/passwd` 文件。
***
### 任务 3.B：使用 Ubuntu 内置方案

打开保护并再次进行攻击：

![](../../../../../assets/Pasted%20image%2020250721223337.png)

可以看到攻击失败了，连文件也打不开了，这就是因为当设置粘滞位比特后，只有文件所有者、目录所有者或 root 用户才能重命名或删除粘滞目录中的文件。`/tmp` 目录设置了粘滞位比特。当粘滞符号保护开启后，全局可写的粘滞目录（如 `tmp`）中的符号链接的所有者，与跟随者和目录所有者的其中之一相匹配时才能被跟随。

本次竞态条件攻击中，漏洞程序以 root 权限运行，即跟随者为 root，`/tmp` 目录的所有者也是 root，但是符号链接所有者时攻击者本身（seed）。所以系统不允许程序使用该符号链接。

这样的方案也有局限性，它仅适用于 `/tmp` 这样的粘滞目录。