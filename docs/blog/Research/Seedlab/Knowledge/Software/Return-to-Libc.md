---
hide:
  #- navigation # 显示右
  #- toc #显示左
  - footer
  - feedback
comments: true
---  

# Return-to-Libc

## Non-Executable Stack

为了防止缓冲区溢出攻击，现代操作系统通常会将栈设置为不可执行，这样攻击者就无法在栈上执行恶意代码。gcc 编译器选项 `-z execstack` 表示栈可执行，`-z noexecstack` 表示栈不可执行。这样的选项在二进制文件的头部会有相应的标识。

!!! tip "Tip"

	事实上，我们可以直接编译程序，不使用编译器选项而使用一个命令行 `execstack -s <binary>` 来设置栈为可执行，使用 `execstack -c <binary>` 来设置栈为不可执行。
***
## Return-to-libc Attack : Idea and Challenges

当我们的栈不可执行时，我们就没法通过缓冲区溢出攻击将 shellcode 放到栈上并执行了，但我们仍然可以通过缓冲区溢出攻击来修改返回地址，使其指向一些已经存在于内存当中的代码，而存在于内存中的代码有三类：

- 程序本身的代码段，但是程序本身不一定含有我们想要执行的代码
- 库函数
- 内核代码，但是内核代码是受保护的，我们无法直接调用

因此，库函数成为了我们最稳妥的选择，在 C 代码中有一类标准 C 库函数称为 libc 函数，它在大多数程序当中都会以动态链接的方式存在于内存当中，且 libc 函数包含了 `system()` 函数，能让我们获得一个 Shell 从而执行任意命令。

当然，虽然 libc 函数是我们最常用的攻击目标，但它也有一些挑战：

- `system()` 函数的地址在哪？
- `/bin/sh` 字符串的地址在哪？
- 我们如何传递字符串 `/bin/sh` 的地址给 `system()` 函数？
***
## Overcome the Challenges

### Find system() 's Address

我们可以通过 gdb 调试，当运行 main 函数时，会有一系列库导入，这样我们就可以获得 system 函数的地址：

![](../../../../../assets/Pasted%20image%2020250717202824.png)

需要注意的是，在地址随机化未开启的情况下，system 函数的地址也是随程序的变化而变化的（即使是在于程序是否为 SetUID 程序的区别都有可能不同），所以攻击者应该调试和需要攻击的程序完全一致的程序。
***
### Find /bin/sh 's Address

一般情况下，字符串一定会存在于内存当中，但是其地址并不好找，我们可以通过另一种方式来解决这个问题——环境变量。

对于一个 SetUID 程序来说，父进程的环境变量将会被传递给子进程，而我们可以在父进程中设置一个环境变量，其值为 `/bin/sh`，然后在子进程中读取这个环境变量的地址即可。

![](../../../../../assets/Pasted%20image%2020250717203525.png)

- 需要注意的是，我们在设置二进制文件名时，需要让这个文件名长度和需要攻击的程序名一致，否则会导致环境变量的地址不一致，例如上图，如果我们要攻击 `stack` 程序，那么我们就得设置长度为 5 的程序
	- 这是因为在将环境变量放到栈上之前，程序的文件名也被放到了栈上

![](../../../../../assets/Pasted%20image%2020250717203826.png)
***
### Passing Arguments

这是 Return-to-libc 攻击最难的部分，它的难点在于，当我们跳转到 `system()` 函数时，会分配一个新的属于 `system()` 函数的栈帧，同时 ebp 会改变，我们知道函数的第一个参数的地址为 `ebp + 8`，理论上我们只要将这个地址的内容改成 `/bin/sh` 字符串的地址即可，但是重点在于我们不知道 ebp 改变成了什么。

!!! note "Ebp 的改变"

	ebp 的改变一般有两种情况，一种是函数退出，另一种即为进入函数。
	
	![](../../../../../assets/Pasted%20image%2020250717204559.png)
	
	如上图，Function Prologue 表示函数的开始部分，Function Epilogue 表示函数的结束部分，其中我们可以看到开始部分 ebp 被保存到栈上，然后 ebp 被设置为当前栈顶的地址，结束部分 `leave` 指令则代表了两条指令（`movl %ebp, %esp` 和 `popl %ebp`），这使得 ebp 的值被恢复为之前保存的值。

我们可以深入探究一下，当我们从一个函数跳转到另一个函数时，ebp 和 esp 是如何变化的

!!! note "ebp 和 esp 的变化"

	![](../../../../../assets/Pasted%20image%2020250717205353.png)
	
	如上图所示，我们假设 ebp 的初始值为 X，将 leave 指令展开，一步一步执行汇编代码：
	
	- A 函数的结束部分：
		- `movl %ebp, %esp` 将 esp 设置为 ebp 的值，即 X
		- `popl %ebp` 将栈顶的值弹出到 ebp 中，即地址为 X 的内容，设为 Y，同时 esp 的值变为 X + 4（因为弹出一个 4 字节的值）
		- `ret` 指令将 esp 的值变为 X + 8（因为 `ret` 指令本质上也包含一个 `popl`，会将栈顶的值当作一个地址并跳转到这个地址）
	- B 函数的开始部分：
		- `pushl %ebp` 将 ebp 的值推到栈中，将 esp 的值变为 X + 4
		- `movl %esp, %ebp` 将 esp 的值赋给 ebp，最终 ebp 变成了 X + 4

最终，我们通过上面的推导可以得知，ebp 最终变化为了 ebp + 4，因此，假设 ebp 相对于 buffer 的偏移量为 32，我们的恶意 badfile 应该架构如下：

![](../../../../../assets/Pasted%20image%2020250717210546.png)

其中需要注意的是，当我们跳转到 system 函数时，ebp 变成了 ebp + 4，也就是说 ebp + 8 就成为了 system 函数的返回地址，为了能让函数正常返回，我们将这个地址设置为 exit 函数的地址（否则有可能这个地方会被设置成随机值而导致程序崩溃）
***









